<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SuperLU Distributed: SRC/pdgssvx3d.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SuperLU Distributed
   &#160;<span id="projectnumber">8.1.0</span>
   </div>
   <div id="projectbrief">gpu3d-batch</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('pdgssvx3d_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pdgssvx3d.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Solves a system of linear equations A*X=B using 3D process grid.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="superlu__ddefs_8h_source.html">superlu_ddefs.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="superlu__summit_8h_source.html">TRF3dV100/superlu_summit.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for pdgssvx3d.c:</div>
<div class="dyncontent">
<div class="center"><img src="pdgssvx3d_8c__incl.png" border="0" usemap="#aSRC_2pdgssvx3d_8c" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a002b2f4894492820fe708b1b7e7c5e70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pdgssvx3d_8c.html#a002b2f4894492820fe708b1b7e7c5e70">EPSILON</a>&#160;&#160;&#160;1e-3</td></tr>
<tr class="separator:a002b2f4894492820fe708b1b7e7c5e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8823548d26242c8a12b0b51e9360740d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pdgssvx3d_8c.html#a8823548d26242c8a12b0b51e9360740d">writeLUtoDisk</a> (int nsupers, <a class="el" href="superlu__defs_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a> *xsup, <a class="el" href="structdLUstruct__t.html">dLUstruct_t</a> *LUstruct)</td></tr>
<tr class="separator:a8823548d26242c8a12b0b51e9360740d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43372935c8c9a4411a455aa0083951f1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pdgssvx3d_8c.html#a43372935c8c9a4411a455aa0083951f1">checkArr</a> (double *A, double *B, int n)</td></tr>
<tr class="separator:a43372935c8c9a4411a455aa0083951f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fd5829a78a1543462337a0794de794"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pdgssvx3d_8c.html#a57fd5829a78a1543462337a0794de794">checkLUFromDisk</a> (int nsupers, <a class="el" href="superlu__defs_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a> *xsup, <a class="el" href="structdLUstruct__t.html">dLUstruct_t</a> *LUstruct)</td></tr>
<tr class="separator:a57fd5829a78a1543462337a0794de794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd295688eb2d11cd956c465f54af439"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pdgssvx3d_8c.html#a4cd295688eb2d11cd956c465f54af439">pdgssvx3d</a> (<a class="el" href="structsuperlu__dist__options__t.html">superlu_dist_options_t</a> *options, <a class="el" href="structSuperMatrix.html">SuperMatrix</a> *A, <a class="el" href="structdScalePermstruct__t.html">dScalePermstruct_t</a> *ScalePermstruct, double B[], int ldb, int nrhs, <a class="el" href="structgridinfo3d__t.html">gridinfo3d_t</a> *grid3d, <a class="el" href="structdLUstruct__t.html">dLUstruct_t</a> *LUstruct, <a class="el" href="structdSOLVEstruct__t.html">dSOLVEstruct_t</a> *SOLVEstruct, double *berr, <a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *stat, int *info)</td></tr>
<tr class="separator:a4cd295688eb2d11cd956c465f54af439"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Solves a system of linear equations A*X=B using 3D process grid. </p>
<p>Copyright (c) 2003, The Regents of the University of California, through Lawrence Berkeley National Laboratory (subject to receipt of any required approvals from U.S. Dept. of Energy)</p>
<p>All rights reserved.</p>
<p>The source code is distributed under BSD license, see the file License.txt at the top-level directory.</p>
<pre>
   -- Distributed SuperLU routine (version 7.2) --
   Lawrence Berkeley National Lab, Georgia Institute of Technology,
   Oak Ridge National Lab
   May 12, 2021
   October 5, 2021
   Last update: November 8, 2021  v7.2.0
 */



/*!


   <pre>
   Purpose
   =======

   PDGSSVX3D solves a system of linear equations A*X=B,
   by using Gaussian elimination with "static pivoting" to
   compute the LU factorization of A.

   Static pivoting is a technique that combines the numerical stability
   of partial pivoting with the scalability of Cholesky (no pivoting),
   to run accurately and efficiently on large numbers of processors.
   See our paper at <a href="http://www.nersc.gov/~xiaoye/SuperLU/">http://www.nersc.gov/~xiaoye/SuperLU/</a> for a detailed
   description of the parallel algorithms.

   The input matrices A and B are distributed by block rows.
   Here is a graphical illustration (0-based indexing):

                          A                B
                 0 ---------------       ------
                     |           |        |  |
                     |           |   P0   |  |
                     |           |        |  |
                   ---------------       ------<ul>
<li>fst_row-&gt;|           |        |  |
          |          |           |        |  |
         m_loc       |           |   P1   |  |
          |          |           |        |  |</li>
<li>         |           |        |  |
                   ---------------       ------
                     |    .      |        |. |
                     |    .      |        |. |
                     |    .      |        |. |
                   ---------------       ------

   where, fst_row is the row number of the first row,
          m_loc is the number of rows local to this processor
   These are defined in the '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>' structure, see <a class="el" href="supermatrix_8h.html" title="Matrix type definitions.">supermatrix.h</a>.


   Here are the options for using this code:

     1. Independent of all the other options specified below, the
        user must supply

        -  B, the matrix of right-hand sides, distributed by block rows,
              and its dimensions ldb (local) and nrhs (global)</li>
</ul>
</pre></pre><pre><pre> grid, a structure describing the 2D processor mesh<ul>
<li>options-&gt;IterRefine, which determines whether or not to
              improve the accuracy of the computed solution using
              iterative refinement

        On output, B is overwritten with the solution X.

     2. Depending on options-&gt;Fact, the user has four options
        for solving A*X=B. The standard option is for factoring
        A "from scratch". (The other options, described below,
        are used when A is sufficiently similar to a previously
        solved problem to save time by reusing part or all of
        the previous factorization.)

        -  options-&gt;Fact = DOFACT: A is factored "from scratch"

        In this case the user must also supply

          o  A, the input matrix

          as well as the following options to determine what matrix to
          factorize.

          o  options-&gt;Equil,   to specify how to scale the rows and columns
                               of A to "equilibrate" it (to try to reduce its
                               condition number and so improve the
                               accuracy of the computed solution)

          o  options-&gt;RowPerm, to specify how to permute the rows of A
                               (typically to control numerical stability)

          o  options-&gt;ColPerm, to specify how to permute the columns of A
                               (typically to control fill-in and enhance
                               parallelism during factorization)

          o  options-&gt;ReplaceTinyPivot, to specify how to deal with tiny
                               pivots encountered during factorization
                               (to control numerical stability)

        The outputs returned include

          o  ScalePermstruct,  modified to describe how the input matrix A
                               was equilibrated and permuted:
            .  ScalePermstruct-&gt;DiagScale, indicates whether the rows and/or
                                           columns of A were scaled
            .  ScalePermstruct-&gt;R, array of row scale factors
            .  ScalePermstruct-&gt;C, array of column scale factors
            .  ScalePermstruct-&gt;perm_r, row permutation vector
            .  ScalePermstruct-&gt;perm_c, column permutation vector

            (part of ScalePermstruct may also need to be supplied on input,
             depending on options-&gt;RowPerm and options-&gt;ColPerm as described
             later).

          o  A, the input matrix A overwritten by the scaled and permuted
                matrix diag(R)*A*diag(C)*Pc^T, where
                Pc is the row permutation matrix determined by
                    ScalePermstruct-&gt;perm_c
                diag(R) and diag(C) are diagonal scaling matrices determined
                    by ScalePermstruct-&gt;DiagScale, ScalePermstruct-&gt;R and
                    ScalePermstruct-&gt;C

          o  LUstruct, which contains the L and U factorization of A1 where

                  A1 = Pc*Pr*diag(R)*A*diag(C)*Pc^T = L*U

                 (Note that A1 = Pc*Pr*Aout, where Aout is the matrix stored
                  in A on output.)

     3. The second value of options-&gt;Fact assumes that a matrix with the same
        sparsity pattern as A has already been factored:

        -  options-&gt;Fact = SamePattern: A is factored, assuming that it has
              the same nonzero pattern as a previously factored matrix. In
              this case the algorithm saves time by reusing the previously
              computed column permutation vector stored in
              ScalePermstruct-&gt;perm_c and the "elimination tree" of A
              stored in LUstruct-&gt;etree

        In this case the user must still specify the following options
        as before:

          o  options-&gt;Equil
          o  options-&gt;RowPerm
          o  options-&gt;ReplaceTinyPivot

        but not options-&gt;ColPerm, whose value is ignored. This is because the
        previous column permutation from ScalePermstruct-&gt;perm_c is used as
        input. The user must also supply

          o  A, the input matrix
          o  ScalePermstruct-&gt;perm_c, the column permutation
          o  LUstruct-&gt;etree, the elimination tree

        The outputs returned include

          o  A, the input matrix A overwritten by the scaled and permuted
                matrix as described above
          o  ScalePermstruct, modified to describe how the input matrix A was
                              equilibrated and row permuted
          o  LUstruct, modified to contain the new L and U factors

     4. The third value of options-&gt;Fact assumes that a matrix B with the same
        sparsity pattern as A has already been factored, and where the
        row permutation of B can be reused for A. This is useful when A and B
        have similar numerical values, so that the same row permutation
        will make both factorizations numerically stable. This lets us reuse
        all of the previously computed structure of L and U.

        -  options-&gt;Fact = SamePattern_SameRowPerm: A is factored,
              assuming not only the same nonzero pattern as the previously
              factored matrix B, but reusing B's row permutation.

        In this case the user must still specify the following options
        as before:

          o  options-&gt;Equil
          o  options-&gt;ReplaceTinyPivot

        but not options-&gt;RowPerm or options-&gt;ColPerm, whose values are
        ignored. This is because the permutations from ScalePermstruct-&gt;perm_r
        and ScalePermstruct-&gt;perm_c are used as input.

        The user must also supply

          o  A, the input matrix
          o  ScalePermstruct-&gt;DiagScale, how the previous matrix was row
                                         and/or column scaled
          o  ScalePermstruct-&gt;R, the row scalings of the previous matrix,
                                 if any
          o  ScalePermstruct-&gt;C, the columns scalings of the previous matrix,
                                 if any
          o  ScalePermstruct-&gt;perm_r, the row permutation of the previous
                                      matrix
          o  ScalePermstruct-&gt;perm_c, the column permutation of the previous
                                      matrix
          o  all of LUstruct, the previously computed information about
                              L and U (the actual numerical values of L and U
                              stored in LUstruct-&gt;Llu are ignored)

        The outputs returned include

          o  A, the input matrix A overwritten by the scaled and permuted
                matrix as described above
          o  ScalePermstruct,  modified to describe how the input matrix A was
                               equilibrated (thus ScalePermstruct-&gt;DiagScale,
                               R and C may be modified)
          o  LUstruct, modified to contain the new L and U factors

     5. The fourth and last value of options-&gt;Fact assumes that A is
        identical to a matrix that has already been factored on a previous
        call, and reuses its entire LU factorization

        -  options-&gt;Fact = Factored: A is identical to a previously
              factorized matrix, so the entire previous factorization
              can be reused.

        In this case all the other options mentioned above are ignored
        (options-&gt;Equil, options-&gt;RowPerm, options-&gt;ColPerm,
         options-&gt;ReplaceTinyPivot)

        The user must also supply

          o  A, the unfactored matrix, only in the case that iterative
                refinment is to be done (specifically A must be the output
                A from the previous call, so that it has been scaled and permuted)
          o  all of ScalePermstruct
          o  all of LUstruct, including the actual numerical values of
             L and U

        all of which are unmodified on output.

   Arguments
   =========

   options (input) superlu_dist_options_t* (global)
           The structure defines the input parameters to control
           how the LU decomposition will be performed.
           The following fields should be defined for this structure:

           o Fact (fact_t)
             Specifies whether or not the factored form of the matrix
             A is supplied on entry, and if not, how the matrix A should
             be factorized based on the previous history.

             = DOFACT: The matrix A will be factorized from scratch.
                   Inputs:  A
                            options-&gt;Equil, RowPerm, ColPerm, ReplaceTinyPivot
                   Outputs: modified A
                               (possibly row and/or column scaled and/or
                                permuted)
                            all of ScalePermstruct
                            all of LUstruct

             = SamePattern: the matrix A will be factorized assuming
               that a factorization of a matrix with the same sparsity
               pattern was performed prior to this one. Therefore, this
               factorization will reuse column permutation vector
               ScalePermstruct-&gt;perm_c and the elimination tree
               LUstruct-&gt;etree
                   Inputs:  A
                            options-&gt;Equil, RowPerm, ReplaceTinyPivot
                            ScalePermstruct-&gt;perm_c
                            LUstruct-&gt;etree
                   Outputs: modified A
                               (possibly row and/or column scaled and/or
                                permuted)
                            rest of ScalePermstruct (DiagScale, R, C, perm_r)
                            rest of LUstruct (GLU_persist, Llu)

             = SamePattern_SameRowPerm: the matrix A will be factorized
               assuming that a factorization of a matrix with the same
               sparsity pattern and similar numerical values was performed
               prior to this one. Therefore, this factorization will reuse
               both row and column scaling factors R and C, and the
               both row and column permutation vectors perm_r and perm_c,
               distributed data structure set up from the previous symbolic
               factorization.
                   Inputs:  A
                            options-&gt;Equil, ReplaceTinyPivot
                            all of ScalePermstruct
                            all of LUstruct
                   Outputs: modified A
                               (possibly row and/or column scaled and/or
                                permuted)
                            modified LUstruct-&gt;Llu
             = FACTORED: the matrix A is already factored.
                   Inputs:  all of ScalePermstruct
                            all of LUstruct

           o Equil (yes_no_t)
             Specifies whether to equilibrate the system.
             = NO:  no equilibration.
             = YES: scaling factors are computed to equilibrate the system:
                        diag(R)*A*diag(C)*inv(diag(C))*X = diag(R)*B.
                    Whether or not the system will be equilibrated depends
                    on the scaling of the matrix A, but if equilibration is
                    used, A is overwritten by diag(R)*A*diag(C) and B by
                    diag(R)*B.

           o RowPerm (rowperm_t)
             Specifies how to permute rows of the matrix A.
             = NATURAL:   use the natural ordering.
             = LargeDiag_MC64: use the Duff/Koster algorithm to permute rows of
                          the original matrix to make the diagonal large
                          relative to the off-diagonal.
             = LargeDiag_HPWM: use the parallel approximate-weight perfect
                          matching to permute rows of the original matrix
                          to make the diagonal large relative to the
                          off-diagonal.
             = MY_PERMR:  use the ordering given in ScalePermstruct-&gt;perm_r
                          input by the user.

           o ColPerm (colperm_t)
             Specifies what type of column permutation to use to reduce fill.
             = NATURAL:       natural ordering.
             = MMD_AT_PLUS_A: minimum degree ordering on structure of A'+A.
             = MMD_ATA:       minimum degree ordering on structure of A'*A.
             = MY_PERMC:      the ordering given in ScalePermstruct-&gt;perm_c.

           o ReplaceTinyPivot (yes_no_t)
             = NO:  do not modify pivots
             = YES: replace tiny pivots by sqrt(epsilon)*norm(A) during
                    LU factorization.

           o IterRefine (IterRefine_t)
             Specifies how to perform iterative refinement.
             = NO:     no iterative refinement.
             = SLU_DOUBLE: accumulate residual in double precision.
             = SLU_EXTRA:  accumulate residual in extra precision.

           NOTE: all options must be indentical on all processes when
                 calling this routine.

   A (input) SuperMatrix* (local); A resides on all 3D processes.
           On entry, matrix A in A*X=B, of dimension (A-&gt;nrow, A-&gt;ncol).
             The number of linear equations is A-&gt;nrow. The type of A must be:
             Stype = SLU_NR_loc; Dtype = SLU_D; Mtype = SLU_GE.
             That is, A is stored in distributed compressed row format.
             See <a class="el" href="supermatrix_8h.html" title="Matrix type definitions.">supermatrix.h</a> for the definition of '<a class="el" href="structSuperMatrix.html">SuperMatrix</a>'.
             This routine only handles square A, however, the LU factorization
             routine PDGSTRF can factorize rectangular matrices.

       Internally, A is gathered on 2D processs grid-0, call it A2d.
           On exit, A2d may be overwtirren by diag(R)*A*diag(C)*Pc^T,
             depending on ScalePermstruct-&gt;DiagScale and options-&gt;ColPerm:
               if ScalePermstruct-&gt;DiagScale != NOEQUIL, A2d is overwritten by
                  diag(R)*A*diag(C).
               if options-&gt;ColPerm != NATURAL, A2d is further overwritten by
                  diag(R)*A*diag(C)*Pc^T.
             If all the above condition are true, the LU decomposition is
             performed on the matrix Pc*Pr*diag(R)*A*diag(C)*Pc^T.

   ScalePermstruct (input/output) dScalePermstruct_t* (global)
           The data structure to store the scaling and permutation vectors
           describing the transformations performed to the matrix A.
           It contains the following fields:

           o DiagScale (DiagScale_t)
             Specifies the form of equilibration that was done.
             = NOEQUIL: no equilibration.
             = ROW:     row equilibration, i.e., A was premultiplied by
                        diag(R).
             = COL:     Column equilibration, i.e., A was postmultiplied
                        by diag(C).
             = BOTH:    both row and column equilibration, i.e., A was
                        replaced by diag(R)*A*diag(C).
             If options-&gt;Fact = FACTORED or SamePattern_SameRowPerm,
             DiagScale is an input argument; otherwise it is an output
             argument.

           o perm_r (int*)
             Row permutation vector, which defines the permutation matrix Pr;
             perm_r[i] = j means row i of A is in position j in Pr*A.
             If options-&gt;RowPerm = MY_PERMR, or
             options-&gt;Fact = SamePattern_SameRowPerm, perm_r is an
             input argument; otherwise it is an output argument.

           o perm_c (int*)
             Column permutation vector, which defines the
             permutation matrix Pc; perm_c[i] = j means column i of A is
             in position j in A*Pc.
             If options-&gt;ColPerm = MY_PERMC or options-&gt;Fact = SamePattern
             or options-&gt;Fact = SamePattern_SameRowPerm, perm_c is an
             input argument; otherwise, it is an output argument.
             On exit, perm_c may be overwritten by the product of the input
             perm_c and a permutation that postorders the elimination tree
             of Pc*A'*A*Pc'; perm_c is not changed if the elimination tree
             is already in postorder.

           o R (double *) dimension (A-&gt;nrow)
             The row scale factors for A.
             If DiagScale = ROW or BOTH, A is multiplied on the left by
                            diag(R).
             If DiagScale = NOEQUIL or COL, R is not defined.
             If options-&gt;Fact = FACTORED or SamePattern_SameRowPerm, R is
             an input argument; otherwise, R is an output argument.

           o C (double *) dimension (A-&gt;ncol)
             The column scale factors for A.
             If DiagScale = COL or BOTH, A is multiplied on the right by
                            diag(C).
             If DiagScale = NOEQUIL or ROW, C is not defined.
             If options-&gt;Fact = FACTORED or SamePattern_SameRowPerm, C is
             an input argument; otherwise, C is an output argument.

   B       (input/output) double* (local)
           On entry, the right-hand side matrix of dimension (m_loc, nrhs),
             where, m_loc is the number of rows stored locally on my
             process and is defined in the data structure of matrix A.
           On exit, the solution matrix if info = 0;

   ldb     (input) int (local)
           The leading dimension of matrix B.

   nrhs    (input) int (global)
           The number of right-hand sides.
           If nrhs = 0, only LU decomposition is performed, the forward
           and back substitutions are skipped.

   grid    (input) gridinfo_t* (global)
           The 2D process mesh. It contains the MPI communicator, the number
           of process rows (NPROW), the number of process columns (NPCOL),
           and my process rank. It is an input argument to all the
           parallel routines.
           Grid can be initialized by subroutine SUPERLU_GRIDINIT.
           See <a class="el" href="superlu__ddefs_8h.html" title="Distributed SuperLU data types and function prototypes.">superlu_ddefs.h</a> for the definition of '<a class="el" href="structgridinfo__t.html">gridinfo_t</a>'.

   LUstruct (input/output) dLUstruct_t*
           The data structures to store the distributed L and U factors.
           It contains the following fields:

           o etree (int*) dimension (A-&gt;ncol) (global)
             Elimination tree of Pc*(A'+A)*Pc' or Pc*A'*A*Pc'.
             It is computed in <a class="el" href="sp__colorder_8c.html#a6ad60314d2dc47dad994c8c9d30a47c1">sp_colorder()</a> during the first factorization,
             and is reused in the subsequent factorizations of the matrices
             with the same nonzero pattern.
             On exit of <a class="el" href="sp__colorder_8c.html#a6ad60314d2dc47dad994c8c9d30a47c1">sp_colorder()</a>, the columns of A are permuted so that
             the etree is in a certain postorder. This postorder is reflected
             in ScalePermstruct-&gt;perm_c.
             NOTE:
             Etree is a vector of parent pointers for a forest whose vertices
             are the integers 0 to A-&gt;ncol-1; etree[root]==A-&gt;ncol.

           o Glu_persist (Glu_persist_t*) (global)
             Global data structure (xsup, supno) replicated on all processes,
             describing the supernode partition in the factored matrices
             L and U:
           xsup[s] is the leading column of the s-th supernode,
               supno[i] is the supernode number to which column i belongs.

           o Llu (dLocalLU_t*) (local)
             The distributed data structures to store L and U factors.
             See <a class="el" href="superlu__ddefs_8h.html" title="Distributed SuperLU data types and function prototypes.">superlu_ddefs.h</a> for the definition of '<a class="el" href="structdLocalLU__t.html">dLocalLU_t</a>'.

   SOLVEstruct (input/output) dSOLVEstruct_t*
           The data structure to hold the communication pattern used
           in the phases of triangular solution and iterative refinement.
           This pattern should be intialized only once for repeated solutions.
           If options-&gt;SolveInitialized = YES, it is an input argument.
           If options-&gt;SolveInitialized = NO and nrhs != 0, it is an output
           argument. See <a class="el" href="superlu__ddefs_8h.html" title="Distributed SuperLU data types and function prototypes.">superlu_ddefs.h</a> for the definition of '<a class="el" href="structdSOLVEstruct__t.html">dSOLVEstruct_t</a>'.

   berr    (output) double*, dimension (nrhs) (global)
           The componentwise relative backward error of each solution
           vector X(j) (i.e., the smallest relative change in
           any element of A or B that makes X(j) an exact solution).

   stat   (output) SuperLUStat_t*
          Record the statistics on runtime and floating-point operation count.
          See <a class="el" href="util__dist_8h.html" title="Header for utilities.">util_dist.h</a> for the definition of '<a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a>'.

   info    (output) int*
           = 0: successful exit
           &lt; 0: if info = -i, the i-th argument had an illegal value
           &gt; 0: if info = i, and i is
               &lt;= A-&gt;ncol: U(i,i) is exactly zero. The factorization has
                  been completed, but the factor U is exactly singular,
                  so the solution could not be computed.
               &gt; A-&gt;ncol: number of bytes allocated when memory allocation
                  failure occurred, plus A-&gt;ncol.

   See <a class="el" href="superlu__ddefs_8h.html" title="Distributed SuperLU data types and function prototypes.">superlu_ddefs.h</a> for the definitions of varioous data types.
   
</li>
</ul>
</pre></pre></div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a002b2f4894492820fe708b1b7e7c5e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002b2f4894492820fe708b1b7e7c5e70">&#9670;&nbsp;</a></span>EPSILON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EPSILON&#160;&#160;&#160;1e-3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a43372935c8c9a4411a455aa0083951f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43372935c8c9a4411a455aa0083951f1">&#9670;&nbsp;</a></span>checkArr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int checkArr </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="pdgssvx3d_8c_a43372935c8c9a4411a455aa0083951f1_icgraph.png" border="0" usemap="#apdgssvx3d_8c_a43372935c8c9a4411a455aa0083951f1_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a57fd5829a78a1543462337a0794de794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fd5829a78a1543462337a0794de794">&#9670;&nbsp;</a></span>checkLUFromDisk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int checkLUFromDisk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nsupers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="superlu__defs_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a> *&#160;</td>
          <td class="paramname"><em>xsup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdLUstruct__t.html">dLUstruct_t</a> *&#160;</td>
          <td class="paramname"><em>LUstruct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="pdgssvx3d_8c_a57fd5829a78a1543462337a0794de794_cgraph.png" border="0" usemap="#apdgssvx3d_8c_a57fd5829a78a1543462337a0794de794_cgraph" alt=""/></div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="pdgssvx3d_8c_a57fd5829a78a1543462337a0794de794_icgraph.png" border="0" usemap="#apdgssvx3d_8c_a57fd5829a78a1543462337a0794de794_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a4cd295688eb2d11cd956c465f54af439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd295688eb2d11cd956c465f54af439">&#9670;&nbsp;</a></span>pdgssvx3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pdgssvx3d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsuperlu__dist__options__t.html">superlu_dist_options_t</a> *&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperMatrix.html">SuperMatrix</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdScalePermstruct__t.html">dScalePermstruct_t</a> *&#160;</td>
          <td class="paramname"><em>ScalePermstruct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>B</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgridinfo3d__t.html">gridinfo3d_t</a> *&#160;</td>
          <td class="paramname"><em>grid3d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdLUstruct__t.html">dLUstruct_t</a> *&#160;</td>
          <td class="paramname"><em>LUstruct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdSOLVEstruct__t.html">dSOLVEstruct_t</a> *&#160;</td>
          <td class="paramname"><em>SOLVEstruct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>berr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSuperLUStat__t.html">SuperLUStat_t</a> *&#160;</td>
          <td class="paramname"><em>stat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="pdgssvx3d_8c_a4cd295688eb2d11cd956c465f54af439_icgraph.png" border="0" usemap="#apdgssvx3d_8c_a4cd295688eb2d11cd956c465f54af439_icgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a8823548d26242c8a12b0b51e9360740d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8823548d26242c8a12b0b51e9360740d">&#9670;&nbsp;</a></span>writeLUtoDisk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int writeLUtoDisk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nsupers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="superlu__defs_8h.html#ab6fd6105e64ed14a0c9281326f05e623">int_t</a> *&#160;</td>
          <td class="paramname"><em>xsup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdLUstruct__t.html">dLUstruct_t</a> *&#160;</td>
          <td class="paramname"><em>LUstruct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="pdgssvx3d_8c_a8823548d26242c8a12b0b51e9360740d_icgraph.png" border="0" usemap="#apdgssvx3d_8c_a8823548d26242c8a12b0b51e9360740d_icgraph" alt=""/></div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_1e771ff450ae847412a8c28572c155bb.html">SRC</a></li><li class="navelem"><a class="el" href="pdgssvx3d_8c.html">pdgssvx3d.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
